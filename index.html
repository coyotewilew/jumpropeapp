<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jump Rope HIIT Timer</title>
  <meta name="theme-color" content="#16a34a">
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; background:#0f172a; }
    body { -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
    * { -webkit-tap-highlight-color: transparent; }
  </style>
</head>
<body>
  <div id="root"></div>
  <!-- React & Babel -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const {useEffect, useMemo, useRef, useState} = React;

    const DEFAULT_CONFIG = {
      rounds: 5,
      workSec: 30,
      restSec: 10,
      roundRestSec: 30,
      sequence: [
        { type: "work", label: "Basic Bounce" },
        { type: "work", label: "Butt Kicks (Jump Rope)" },
        { type: "work", label: "Push-ups" },
        { type: "work", label: "Basic Bounce" },
        { type: "work", label: "High Knees (Jump Rope)" },
        { type: "work", label: "Basic Bounce" },
        { type: "work", label: "Jump Squats" },
        { type: "work", label: "Basic Bounce" },
        { type: "work", label: "Normal Squats" },
      ],
    };

    function secondsToHMS(s) {
      const h = Math.floor(s / 3600);
      const m = Math.floor((s % 3600) / 60);
      const sec = Math.floor(s % 60);
      return [h, m, sec].map(v => String(v).padStart(2, "0")).join(":");
    }

    function useBeep() {
      const ctxRef = useRef(null);
      return () => {
        try {
          const AudioCtx = window.AudioContext || window.webkitAudioContext;
          if (!ctxRef.current) ctxRef.current = new AudioCtx();
          const ctx = ctxRef.current;
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = "sine";
          o.frequency.value = 880;
          g.gain.setValueAtTime(0.001, ctx.currentTime);
          g.gain.exponentialRampToValueAtTime(0.3, ctx.currentTime + 0.01);
          g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.25);
          o.connect(g); g.connect(ctx.destination);
          o.start(); o.stop(ctx.currentTime + 0.25);
        } catch {}
      };
    }

    function App() {
      const [config, setConfig] = useState(DEFAULT_CONFIG);
      const [isRunning, setIsRunning] = useState(false);
      const [softPaused, setSoftPaused] = useState(false);
      const [tick, setTick] = useState(0);
      const [elapsed, setElapsed] = useState(0);

      const beep = useBeep();

      // --- Wake Lock + NoSleep fallback
      const wakeLockRef = useRef(null);
      const noSleepRef = useRef(null);

      const loadNoSleep = async () => {
        if (noSleepRef.current || window.NoSleep) return noSleepRef.current || new window.NoSleep();
        return new Promise((resolve) => {
          const s = document.createElement('script');
          s.src = 'https://unpkg.com/nosleep.js@0.12.0/dist/NoSleep.min.js';
          s.async = true;
          s.onload = () => {
            try {
              const ns = new window.NoSleep();
              noSleepRef.current = ns;
              resolve(ns);
            } catch (e) { resolve(null); }
          };
          s.onerror = () => resolve(null);
          document.head.appendChild(s);
        });
      };

      const requestWakeLock = async () => {
        try {
          if ('wakeLock' in navigator && !wakeLockRef.current) {
            wakeLockRef.current = await navigator.wakeLock.request('screen');
            wakeLockRef.current.addEventListener?.('release', () => {});
          }
        } catch {}
      };

      const releaseWakeLock = async () => {
        try { await wakeLockRef.current?.release?.(); } catch {}
        wakeLockRef.current = null;
      };

      const enableKeepAwake = async () => {
        await requestWakeLock();
        try {
          const ns = (await loadNoSleep()) || null;
          ns && ns.enable && ns.enable();
        } catch {}
      };

      const disableKeepAwake = async () => {
        try { noSleepRef.current && noSleepRef.current.disable && noSleepRef.current.disable(); } catch {}
        await releaseWakeLock();
      };

      const timeline = useMemo(() => {
        const items = [];
        for (let r = 1; r <= config.rounds; r++) {
          config.sequence.forEach((step, i) => {
            items.push({ phase: step.type, label: step.label, duration: config.workSec, round: r, idxInRound: i + 1 });
            if (i < config.sequence.length - 1) {
              items.push({ phase: "rest", label: "Rest", duration: config.restSec, round: r, idxInRound: i + 1 });
            }
          });
          if (r < config.rounds && config.roundRestSec > 0) {
            items.push({ phase: "round-rest", label: "Round Rest", duration: config.roundRestSec, round: r, idxInRound: config.sequence.length });
          }
        }
        let t = 0;
        items.forEach((it) => { it.start = t; t += it.duration; it.end = t; });
        items.totalDuration = t;
        return items;
      }, [config]);

      const current = useMemo(() => {
        const t = elapsed;
        const item = timeline.find((it) => t >= it.start && t < it.end) || null;
        const remainingInItem = item ? Math.ceil(item.end - t) : 0;
        const remainingTotal = Math.max(0, Math.ceil(timeline.totalDuration - t));
        const progress = timeline.totalDuration ? Math.min(1, t / timeline.totalDuration) : 0;
        return { item, remainingInItem, remainingTotal, progress };
      }, [elapsed, timeline]);

      useEffect(() => {
        const onVis = () => {
          if (document.visibilityState === 'visible' && isRunning && !softPaused) enableKeepAwake();
        };
        document.addEventListener('visibilitychange', onVis);
        return () => document.removeEventListener('visibilitychange', onVis);
      }, [isRunning, softPaused]);

      useEffect(() => {
        if (!isRunning || softPaused) return;
        const id = setInterval(() => setTick((x) => x + 1), 250);
        return () => clearInterval(id);
      }, [isRunning, softPaused]);

      useEffect(() => {
        if (!isRunning || softPaused) return;
        setElapsed((t) => Math.min(t + 0.25, timeline.totalDuration));
      }, [tick, isRunning, softPaused, timeline.totalDuration]);

      const lastPhaseRef = useRef(null);
      useEffect(() => {
        const cur = current.item?.phase;
        if (cur && cur !== lastPhaseRef.current && isRunning) {
          beep();
          lastPhaseRef.current = cur;
        }
      }, [current.item?.phase, isRunning, beep]);

      const start = () => {
        if (elapsed >= timeline.totalDuration) setElapsed(0);
        setIsRunning(true);
        setSoftPaused(false);
        enableKeepAwake();
      };
      const pause = () => { setSoftPaused(true); disableKeepAwake(); };
      const resume = () => { setSoftPaused(false); enableKeepAwake(); };
      const reset = () => {
        setIsRunning(false);
        setSoftPaused(false);
        setElapsed(0);
        lastPhaseRef.current = null;
        disableKeepAwake();
      };

      const skipNext = () => { const item = current.item; if (!item) return; setElapsed(item.end); };
      const skipPrev = () => {
        const t = elapsed - 0.25;
        const idx = timeline.findIndex((it) => t >= it.start && t < it.end);
        if (idx > 0) setElapsed(timeline[idx - 1].start); else setElapsed(0);
      };

      const updateNumber = (key, v) => setConfig((c) => ({ ...c, [key]: Math.max(0, Math.floor(v || 0)) }));
      const phaseColor = (phase) => phase === "work" ? "bg-green-600" : phase === "rest" ? "bg-yellow-600" : phase === "round-rest" ? "bg-blue-700" : "bg-slate-700";
      const percent = (n) => `${Math.round(n * 100)}%`;

      useEffect(() => () => { disableKeepAwake(); }, []);

      return (
        <div className="min-h-screen w-full bg-slate-900 text-slate-100 flex flex-col items-center p-4 md:p-8">
          <div className="w-full max-w-3xl">
            <header className="flex items-center justify-between mb-4 md:mb-6">
              <h1 className="text-2xl md:text-4xl font-extrabold tracking-tight">Jump Rope HIIT Timer</h1>
              <div className="text-right">
                <div className="text-xs uppercase tracking-widest text-slate-400">Session Remaining</div>
                <div className="text-xl md:text-2xl font-bold tabular-nums">{secondsToHMS(current.remainingTotal)}</div>
              </div>
            </header>

            <div className="rounded-2xl bg-slate-800 shadow-xl p-4 md:p-6 grid gap-4">
              <div className={`rounded-xl ${phaseColor(current.item?.phase)} p-4 md:p-6 flex items-center justify-between shadow-inner`}>
                <div>
                  <div className="text-xs md:text-sm uppercase tracking-widest opacity-90">{current.item?.phase === "work" ? "Work" : current.item?.phase === "rest" ? "Rest" : current.item?.phase === "round-rest" ? "Round Rest" : "Ready"}</div>
                  <div className="text-2xl md:text-5xl font-extrabold leading-tight">{current.item?.label || "Press Start"}</div>
                  <div className="text-sm md:text-base opacity-90">Round {current.item?.round || 1} / {config.rounds} • Move {current.item?.idxInRound || 1} / {config.sequence.length}</div>
                </div>
                <div className="text-4xl md:text-7xl font-black tabular-nums">{secondsToHMS(current.remainingInItem || (isRunning ? 0 : config.workSec))}</div>
              </div>

              <div className="w-full bg-slate-700 rounded-full h-3 md:h-4 overflow-hidden">
                <div className="h-full bg-slate-200" style={{ width: percent(current.progress) }} />
              </div>

              <div className="flex flex-wrap gap-2 md:gap-3">
                {!isRunning && (
                  <button onClick={start} className="px-4 py-2 md:px-6 md:py-3 rounded-xl bg-green-600 hover:bg-green-700 font-bold">Start</button>
                )}
                {isRunning && !softPaused && (
                  <button onClick={pause} className="px-4 py-2 md:px-6 md:py-3 rounded-xl bg-yellow-600 hover:bg-yellow-700 font-bold">Pause</button>
                )}
                {isRunning && softPaused && (
                  <button onClick={resume} className="px-4 py-2 md:px-6 md:py-3 rounded-xl bg-green-600 hover:bg-green-700 font-bold">Resume</button>
                )}
                <button onClick={reset} className="px-4 py-2 md:px-6 md:py-3 rounded-xl bg-slate-600 hover:bg-slate-500 font-bold">Reset</button>
                <button onClick={skipPrev} className="px-4 py-2 md:px-6 md:py-3 rounded-xl bg-slate-700 hover:bg-slate-600 font-bold">⟵ Prev</button>
                <button onClick={skipNext} className="px-4 py-2 md:px-6 md:py-3 rounded-xl bg-slate-700 hover:bg-slate-600 font-bold">Next ⟶</button>
              </div>
            </div>

            <div className="mt-6 rounded-2xl bg-slate-800 p-4 md:p-6">
              <div className="text-lg md:text-xl font-bold mb-4">Settings</div>
              <div className="grid grid-cols-2 md:grid-cols-4 gap-3 md:gap-4">
                <NumField label="Rounds" value={config.rounds} onChange={(v) => updateNumber("rounds", v)} />
                <NumField label="Work (sec)" value={config.workSec} onChange={(v) => updateNumber("workSec", v)} />
                <NumField label="Rest (sec)" value={config.restSec} onChange={(v) => updateNumber("restSec", v)} />
                <NumField label="Round Rest (sec)" value={config.roundRestSec} onChange={(v) => updateNumber("roundRestSec", v)} />
              </div>
              <div className="mt-4 text-sm text-slate-300">Total Session: <span className="font-bold text-slate-100">{secondsToHMS(timeline.totalDuration || 0)}</span></div>
            </div>

            <div className="mt-6 grid gap-2">
              <div className="text-sm uppercase tracking-widest text-slate-400">Up Next</div>
              <div className="grid gap-2 max-h-64 overflow-auto pr-1">
                {timeline.map((it, i) => {
                  const active = current.item && current.item.start === it.start;
                  return (
                    <div key={i} className={`p-3 rounded-xl flex items-center justify-between ${active ? "bg-slate-700" : "bg-slate-800"}`}>
                      <div className="flex items-center gap-2">
                        <span className={`inline-block w-2 h-2 rounded-full ${it.phase === "work" ? "bg-green-400" : it.phase === "rest" ? "bg-yellow-400" : "bg-blue-400"}`} />
                        <div className="font-semibold">{it.label}</div>
                      </div>
                      <div className="text-sm tabular-nums text-slate-300">R{it.round} • {secondsToHMS(it.duration)}</div>
                    </div>
                  );
                })}
              </div>
            </div>

            <footer className="mt-8 text-center text-xs text-slate-400">
              Tip: Add this page to your phone's Home Screen for a full-screen timer experience.
            </footer>
          </div>
        </div>
      );
    }

    function NumField({ label, value, onChange }) {
      return (
        <label className="grid gap-1">
          <span className="text-xs uppercase tracking-widest text-slate-400">{label}</span>
          <input
            type="number"
            className="bg-slate-900 border border-slate-700 rounded-xl px-3 py-2 font-bold"
            value={value}
            min={0}
            onChange={(e) => onChange(parseInt(e.target.value, 10))}
          />
        </label>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('sw.js').catch(() => {});
      });
    }
  </script>
</body>
</html>
